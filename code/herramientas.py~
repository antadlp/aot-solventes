import pandas as pd
import numpy as np
import time
import datetime
import sys
import os
import subprocess 
from scipy.signal import savgol_filter
from scipy.signal import argrelextrema
from scipy.signal import find_peaks
import getpass
from call_grompp_conf import *
import os
import matplotlib.pyplot as plt

masa_molar_agua = 18
Na = 6.022*1e23

class herramientas(object):
    
    def df2xyz(self, df, path, frame):
        
        with open(path, 'w') as fp:
            fp.write("    {}".format(len(df)))
            fp.write("\nframe   {}".format(frame))
            
            for idx in df.index:
                sym = df['symbol'].loc[idx]
                x = df['x'].loc[idx]*10
                y = df['y'].loc[idx]*10
                z = df['z'].loc[idx]*10
                
                fp.write("\n{}     {:6.3f}   {:6.3f}   {:6.3f}".format(sym, x, y, z))
                
        return


    def df2xyzb(self, **kwargs):

        path = kwargs.get("path", "NULL")
        df = kwargs.get("df", {})
        frame = kwargs.get("frame", "0")
        factor = kwargs.get("factor", 10)
        
        with open(path, 'w') as fp:
            fp.write("    {}".format(len(df)))
            fp.write("\nframe   {}".format(frame))
            
            for idx in df.index:
                sym = df['symbol'].loc[idx]
                x = df['x'].loc[idx]*factor
                y = df['y'].loc[idx]*factor
                z = df['z'].loc[idx]*factor
                
                fp.write("\n{}     {:6.3f}   {:6.3f}   {:6.3f}".format(sym, x, y, z))
                
        return


    def df2gro(self, **kwargs):

        df = kwargs.get("df", "NULL")
        name = kwargs.get("name", "gro")
        path = kwargs.get("path", "NULL")
        frame = kwargs.get("frame", 0)
        box = kwargs.get("box", [20, 20, 20])
        flag_velocities = kwargs.get("flag_velocities", True)
        
        ftype = kwargs.get("ftype", 'w')

        # Lx = box['x'].iloc[0]
        # Ly = box['y'].iloc[0]
        # Lz = box['z'].iloc[0]

        Lx, Ly, Lz = box

        with open(path, ftype) as fp:
            txt = 'Generated by trjconv : {} t=   {}\n'.format(name, frame)
            fp.write(txt)
            fp.write("    {}\n".format(len(df)))
            
            if flag_velocities:
                for idx in df.index:
                    sym = df['symbol'].loc[idx]
                    sym2 = df['symbol2'].loc[idx]
                    x = df['x'].loc[idx]
                    y = df['y'].loc[idx]
                    z = df['z'].loc[idx]
                    vx = df['vx'].loc[idx]
                    vy = df['vy'].loc[idx]
                    vz = df['vz'].loc[idx]

                    tipo = df['tipo'].loc[idx]
                    symbol = df['symbol'].loc[idx]
                    tipo_mol = df['tipo mol'].loc[idx]

                    c = len(tipo_mol)
                    ntipo = int(tipo[:-c])
                    wtipo = tipo[-c:]

                    fp.write("{:>5d}{:<7}{:>3}{:>5}".format(ntipo, tipo_mol, symbol, idx))
                    fp.write("{:>8.3f}{:>8.3f}{:>8.3f}".format(x, y, z))
                    fp.write("{:>8.4f}{:>8.4f}{:>8.4f}\n".format(vx, vy,vz))
                fp.write("{:>9.4f}{:>9.4f}{:>9.4f}\n".format(Lx, Ly, Lz))
            else:  
                for idx in df.index:
                    sym = df['symbol'].loc[idx]
                    sym2 = df['symbol2'].loc[idx]
                    x = df['x'].loc[idx]
                    y = df['y'].loc[idx]
                    z = df['z'].loc[idx]

                    tipo = df['tipo'].loc[idx]
                    symbol = df['symbol'].loc[idx]
                    tipo_mol = df['tipo mol'].loc[idx]

                    c = len(tipo_mol)
                    ntipo = int(tipo[:-c])
                    wtipo = tipo[-c:]

                    fp.write("{:>5d}{:<7}{:>3}{:>5}".format(ntipo, tipo_mol, symbol, idx))
                    fp.write("{:>8.3f}{:>8.3f}{:>8.3f}\n".format(x, y, z))
                fp.write("{:>9.4f}{:>9.4f}{:>9.4f}\n".format(Lx, Ly, Lz))  
                
                
        return


    def append_df2xyz(self, df, path, frame):

        with open(path, 'a') as fp:
            fp.write("\n    {}".format(len(df)))
            fp.write("\nframe   {}".format(frame))

            for idx in df.index:
                sym = df['symbol'].loc[idx]
                x = df['x'].loc[idx]
                y = df['y'].loc[idx]
                z = df['z'].loc[idx]

                fp.write("\n{}     {:6.3f}   {:6.3f}   {:6.3f}".format(sym, x, y, z))
                    
        return


    def create_movie(self, dic, PATH_MOVIE):

        keys = list(dic.keys())
        df_keys = pd.DataFrame(keys)
        df_keys = df_keys.sort_values(by=0)
        df_keys = df_keys.reset_index(drop=True)        
        
        key = df_keys[0].loc[0]

        df = dic[key]['df']
        self.df2xyz(df, PATH_MOVIE, key)
        
        key_index = list(df_keys.index)

        for ik in key_index[1:]:
            
            key = df_keys[0].loc[ik]    
            
            df = dic[key]['df']
            self.append_df2xyz(df, PATH_MOVIE, key)


        return

    def create_gro_movie(self, dic, df_box, PATH_MOVIE):

        keys = list(dic.keys())

        # frame cero
        key = keys[0]
        df = dic[key]['df']
        box = df_box.loc[[key]]
        self.df2gro(df, box, PATH_MOVIE, key)

        for key in keys[1:]:
            df = dic[key]['df']
            self.append_df2xyz(df, box, PATH_MOVIE, key)


        return


    def nq_criterion(self, **kwargs):
        
        df_SDS = kwargs.get('df_SDS', 'NULL')
        df_Pb = kwargs.get('df_Pb', 'NULL')
        
        box_SDS = kwargs.get('box_SDS', 'NULL')
        box_Pb = kwargs.get('box_Pb', 'NULL')
        
        nq = kwargs.get('nq', 18)
        idxs_SDS = df_SDS.index
        idxs_Pb = df_Pb.index
        
        for q in ['x', 'y', 'z']:
            
            r1 = df_SDS[q].loc[idxs_SDS[0]]
            Lq = box_SDS[q].iloc[0]
            
            gap1 = (3.0/4.0)*Lq
            gap2_SDS = Lq/2.0 
            gap2_Pb = Lq/2.0
            
            if q == 'z':
                gap1 = Lq/2.0 
                gap2_SDS = (3.0/4.0)*Lq
                gap2_Pb = Lq/2.0
            else:
                pass
            
            
            nr = 0
            for idx in idxs_SDS[1:]:
                qi = df_SDS[q].loc[idx]
                rd1 = np.abs(r1-qi)
                if (rd1 >= gap1):
                    nr = nr+1

            if (nr > nq):
                tmp_dic = {}
                tmp_dic[q] = {}
                
                for idx in idxs_SDS:
                    qi = df_SDS[q].loc[idx]
                    if qi >= gap2_SDS:
                        tmp_dic[q][idx] = qi - Lq
                    else:
                        tmp_dic[q][idx] = qi
                        
                tmp_df = pd.DataFrame(tmp_dic)
                df_SDS.update(tmp_df)
                
                tmp_dic = {}
                tmp_dic[q] = {}
                
                for idx in idxs_Pb:
                    qi = df_Pb[q].loc[idx]
                    if qi >= gap2_Pb:
                        tmp_dic[q][idx] = qi - Lq
                    else:
                        tmp_dic[q][idx] = qi
                        
                tmp_df = pd.DataFrame(tmp_dic)
                df_Pb.update(tmp_df)
                
        return df_SDS, df_Pb


    def assign_masses(self, df):

        dic = {}
        dic['masa'] = {}
        for idx in df.index:
            
            sym = df['symbol2'].loc[idx]

            if sym == 'PB':
                m = 207.2
            elif sym == 'S3':
                m = 32.065
            else:
                m = 1.0

            dic['masa'][idx] = m

        return pd.DataFrame(dic)


                
    def get_CM_from_frame(self, **kwargs):

        df_m = kwargs.get('df_m', pd.DataFrame(['empty']))
        df = kwargs.get('df', pd.DataFrame(['empty']))

        if df_m.iloc[0, 0] == 'empty':
            # tomar centro geometrico
            dic = {}
            dic['cmx'] = {}
            dic['cmy'] = {}
            dic['cmz'] = {}

            cmx = df['x'].mean()
            cmy = df['y'].mean()
            cmz = df['z'].mean()
            
            key = 0
            dic['cmx'][key] = cmx
            dic['cmy'][key] = cmy
            dic['cmz'][key] = cmz

            return pd.DataFrame(dic)

        else:

            dic = {}
            dic['cmx'] = {}
            dic['cmy'] = {}
            dic['cmz'] = {}

            sm = df_m['masa']
            mt = df_m['masa'].sum()

            sx = df['x']
            sy = df['y']
            sz = df['z']

            cmx = np.divide(sm.dot(sx), mt)
            cmy = np.divide(sm.dot(sy), mt)
            cmz = np.divide(sm.dot(sz), mt)

            key = 0
            dic['cmx'][key] = cmx
            dic['cmy'][key] = cmy
            dic['cmz'][key] = cmz

            return pd.DataFrame(dic)

    
    def rFromPoint(self, **kwargs):

        df_p = kwargs.get('df_p', 'NULL') # punto fijo
        df_q = kwargs.get('df_q', 'NULL') # atomos
        df_q = df_q[['x', 'y', 'z']]

        point = df_p.values[0]

        df = df_q -point
        result = np.sqrt((df.values**2).sum(axis=1))
        df = pd.DataFrame({'r': result}, index=df.index)

        return df

    def densF_2dt(self, path):

        with open(path, 'r') as fp:
            
            dic_dens = {}
            dic_dens['r'] = {}
            dic_dens['lden'] = {}
            dic_dens['ldens'] = {}    
            for line in fp:
                sp = line.split()
                
                i = int(sp[0])
                r = float(sp[1])
                lden = float(sp[2])
                ldens = float(sp[3])
                
                dic_dens['r'][i] = r
                dic_dens['lden'][i] = lden
                dic_dens['ldens'][i] = ldens
                
                
        return pd.DataFrame(dic_dens)

    def xvg2df(self, **kwargs):
        
        path = kwargs.get('path', "NULL")
        xx = kwargs.get('x', 'x')
        yy = kwargs.get('y', 'y')

        with open(path, 'r') as fp:
            
            dic_gr = {}
            dic_gr[xx] = {}
            dic_gr[yy] = {}
            i = 0
            for line in fp:
                sp = line.split()
                
                
                if sp[0] not in ['#', '@', '@TYPE', 'r', 'g']:
                
                    try:
                        r = float(sp[0])
                    except:
                        print("not a number, pass")
                        continue
                
                    r = float(sp[0])
                    gr = float(sp[1])

                    dic_gr[xx][i] = r
                    dic_gr[yy][i] = gr
                    i+=1

        return pd.DataFrame(dic_gr)


    def order_ltr_files(self, **kwargs):
        """
        **kwargs: path_to_check
        outputs: paths, files
        """
        # works good !!
        PATH_TO_CHECK = kwargs.get('path_to_check', 'NULL')
        cmd = ['ls', '-ltr', PATH_TO_CHECK]
        out_process = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
        stdout, stderr = out_process.communicate()
        files = [item.split()[-1] for item in stdout.decode('utf-8').split('\n')[1:-1]]
        paths = [os.path.join(PATH_TO_CHECK, file) for file in files]
        
        return paths, files


    def getCruces(self, **kwargs):
        """
        kwargs: dic_sys, df_dims, q_gap, b
        """

        dic_sys = kwargs.get('dic_sys', 'NULL')
        df_dims = kwargs.get('df_dims', 'NULL')

        q_gap = kwargs.get('q_gap', 0.5)
        b = kwargs.get('b', 1)

        keys = list(dic_sys.keys())
        df_keys = pd.DataFrame(keys)
        df_keys = df_keys.sort_values(by=0)
        df_keys = df_keys.reset_index(drop=True)

        key_index = list(df_keys.index)

        dic_cross = {}
        dic_cross['timei'] = {}
        dic_cross['timef'] = {}
        dic_cross['id'] = {}
        dic_cross['symbol'] = {}
        dic_cross['symbol2'] = {}
        dic_cross['cross'] = {}
        dic_cross['dq'] = {}

        ss = 0 # cross counter
        for ik in key_index[:-b]:
           
            key1 = df_keys[0].loc[ik]
            key2 = df_keys[0].loc[ik + b]
            
            df_sys1 = dic_sys[key1]['df']
            df_sys2 = dic_sys[key2]['df']
            
            box = df_dims.loc[[key1]]
            
            df_sys_xyz1 = df_sys1[['x', 'y', 'z']]
            df_sys_xyz2 = df_sys2[['x', 'y', 'z']]
            
            df_deltas = df_sys_xyz2 - df_sys_xyz1
            for q in ['x', 'y', 'z']:
                
                Lq = box[q].iloc[0]

                df_dq = df_deltas[np.abs(df_deltas[q]) > Lq*q_gap]
                if len(df_dq) > 0:
                    
                    for idx in df_dq.index:
                        dic_cross['timei'][ss]   = key1
                        dic_cross['timef'][ss]   = key2
                        dic_cross['id'][ss]      = idx
                        dic_cross['symbol'][ss]  = df_sys1['symbol'].loc[idx]
                        dic_cross['symbol2'][ss] = df_sys1['symbol2'].loc[idx]
                        
                        dq = df_dq[q].loc[idx]
                        dic_cross['dq'][ss] = dq
                        
                        if dq < 0: 
                            txt = 'up_' + q
                            dic_cross['cross'][ss] = txt
                            
                        else:
                            txt = 'down_' + q
                            dic_cross['cross'][ss] = txt
                        ss+=1
                else:
                    pass

        return pd.DataFrame(dic_cross)


    def deltasExtended(self, **kwargs):
        """
        kwargs: df, box
        """
        
        df = kwargs.get('df', 'NULL')
        box = kwargs.get('box', 'NULL')
        
        dic = {}
        dic['x'] = {}
        dic['y'] = {}
        dic['z'] = {}
        
        for q in ['x', 'y', 'z']:
            
            Lq = box[q].iloc[0] 
            
            up = 'up_' + q
            down = 'down_' + q
            
            tmp_cross = df[df['cross'].isin([up, down])]
            
            if len(tmp_cross) != 0:
                
                icross = tmp_cross['cross'].iloc[0]
                fcross = tmp_cross['cross'].iloc[-1]
                
                if ((icross == up) and (fcross == down)):
                    dic[q][0] = 0.0
                elif ((icross == up) and (fcross == up)):
                    dic[q][0] = +Lq
                elif ((icross == down) and (fcross == up)):
                    dic[q][0] = 0.0
                elif ((icross == down) and (fcross == down)):
                    dic[q][0] = -Lq
                else:
                    dic[q][0] = 0.0
            else:
                
                dic[q][0] = 0.0
                
        return dic['x'][0], dic['y'][0], dic['z'][0]

    def frame2Angs(self, df):

        df_Angs = df.copy()
        
        tmp_df = df_Angs[['x', 'y', 'z', 'vx', 'vy', 'vz']]*10.0
        df_Angs.update(tmp_df)

        return df_Angs


    def dicFrames2Angs(self, dic):

        dic2 = dic.copy()

        keys = list(dic.keys())
        df_keys = pd.DataFrame(keys)
        df_keys = df_keys.sort_values(by=0)
        df_keys = df_keys.reset_index(drop=True)
        key_index = list(df_keys.index)

        for ik in key_index:
           
            key = df_keys[0].loc[ik]

            df = dic[key]['df']

            tmp_df = self.frame2Angs(df)

            dic2[key]['df'] = tmp_df


        return dic2

    def freeFrontiers(self, **kwargs):
        """
        kwargs: df_cc, dic_sys, df_box
        """

        df_cc = kwargs.get('df_cc', pd.DataFrame(['empty']))
        dic_sys = kwargs.get('dic_sys', 'NULL')
        df_dims = kwargs.get('df_dims', 'NULL')
        
        PATH_INPUTS = kwargs.get('path_inputs', 'NULL')
        FOLDER_SYSTEMS = kwargs.get('folder_systems', 'NULL')
        SYSTEM_NAME = kwargs.get('system_name', 'NULL')

        
        if df_cc.iloc[0, 0] == 'empty':
            df_cc = self.getCruces(dic_sys=dic_sys,
                                   df_dims=df_dims)
        else:
            pass

        dic_new_sys = {}

        keys = list(dic_sys.keys())
        df_keys = pd.DataFrame(keys)
        df_keys = df_keys.sort_values(by=0)
        df_keys = df_keys.reset_index(drop=True)
        key_index = list(df_keys.index)

        for ik in key_index:
            
            dic_e = {}
            dic_e['x'] = {}
            dic_e['y'] = {}
            dic_e['z'] = {}
            
            key = df_keys[0].loc[ik]
            dic_new_sys[key] = {}

            df_sys = dic_sys[key]['df']
            df_e = df_sys.copy()
            
            box = df_dims.loc[[key]]
            
            tmp_cc = df_cc[df_cc['timef'] <= key]
            cross_atoms = tmp_cc['id'].unique()
            
            for iatom in df_sys.index:
                
                if iatom in cross_atoms:
                    
                    tmp2_df = tmp_cc[tmp_cc['id'] == iatom]
                    tmp2_df = tmp2_df.sort_values(by='timef')
                    
                    x = df_sys['x'].loc[iatom]
                    y = df_sys['y'].loc[iatom]
                    z = df_sys['z'].loc[iatom]
                    
                    edx, edy, edz = self.deltasExtended(df=tmp2_df,
                            box=box)
                    
                    ex = x + edx
                    ey = y + edy
                    ez = z + edz
                    
                    dic_e['x'][iatom] = ex
                    dic_e['y'][iatom] = ey
                    dic_e['z'][iatom] = ez
                    
                else:
                    
                    x = df_sys['x'].loc[iatom]
                    y = df_sys['y'].loc[iatom]
                    z = df_sys['z'].loc[iatom]
                    
                    dic_e['x'][iatom] = x
                    dic_e['y'][iatom] = y
                    dic_e['z'][iatom] = z
                    
            tmp_e = pd.DataFrame(dic_e)
            df_e.update(tmp_e)    
            
            dic_new_sys[key]['df'] = df_e

        return dic_new_sys
                        

    def get_CM_from_dic(self, **kwargs):

        dic_grl = kwargs.get('dic_grl', 'NULL')

        keys = list(dic_grl.keys())

        df_m = kwargs.get('df_m', pd.DataFrame(['empty']))

        if df_m.iloc[0, 0] == 'empty':
            # tomar centro geometrico
            dic = {}
            dic['cmx'] = {}
            dic['cmy'] = {}
            dic['cmz'] = {}

            for key in keys:

                df = dic_grl[key]['df']

                cmx = df['x'].mean()
                cmy = df['y'].mean()
                cmz = df['z'].mean()

                dic['cmx'][key] = cmx
                dic['cmy'][key] = cmy
                dic['cmz'][key] = cmz


            return pd.DataFrame(dic)

        else:

            dic = {}
            dic['cmx'] = {}
            dic['cmy'] = {}
            dic['cmz'] = {}

            sm = df_m['masa']
            mt = df_m['masa'].sum()
            for key in keys:

                df = dic_grl[key]['df']

                sx = df['x']
                sy = df['y']
                sz = df['z']

                cmx = np.divide(sm.dot(sx), mt)
                cmy = np.divide(sm.dot(sx), mt)
                cmz = np.divide(sm.dot(sx), mt)

                dic['cmx'][key] = cmx
                dic['cmy'][key] = cmy
                dic['cmz'][key] = cmz

            return pd.DataFrame(dic)

    def freeFrontiers2(self, **kwargs):
        """
        kwargs: df_cc, dic_sys, df_box,
        path_outputs, folder_systems, system_name
        """

        df_cc = kwargs.get('df_cc', pd.DataFrame(['empty']))
        dic_sys = kwargs.get('dic_sys', 'NULL')
        df_dims = kwargs.get('df_dims', 'NULL')
        
        PATH_OUTPUTS = kwargs.get('path_outputs', 'NULL')
        FOLDER_SYSTEMS = kwargs.get('folder_systems', 'NULL')
        SYSTEM_NAME = kwargs.get('system_name', 'NULL')

        NAME_CROSS = FOLDER_SYSTEMS + '_' + SYSTEM_NAME + '_' +\
                'cross.pkl'

        PATH_CROSS = os.path.join(PATH_OUTPUTS, FOLDER_SYSTEMS)
        PATH_CROSS = os.path.join(PATH_CROSS, SYSTEM_NAME)

        cmd = 'mkdir -p ' + PATH_CROSS
        subprocess.call(cmd, shell=True)

        PATH_CROSS = os.path.join(PATH_CROSS, NAME_CROSS)

        if os.path.exists(PATH_CROSS):
            df_cc = pd.read_pickle(PATH_CROSS)
        else:
            df_cc = self.getCruces(dic_sys=dic_sys,
                                   df_dims=df_dims)

        PATH_EXT = os.path.join(PATH_OUTPUTS, FOLDER_SYSTEMS) 
        PATH_EXT = os.path.join(PATH_EXT, SYSTEM_NAME) 
        PATH_EXT = os.path.join(PATH_EXT, 'extended_micelle')

        cmd = 'mkdir -p ' + PATH_EXT
        subprocess.call(cmd, shell=True)

        paths, files = self.order_ltr_files(path_to_check=PATH_EXT)
        num_ext_frames = len(files)
        print(num_ext_frames)

        keys = list(dic_sys.keys())
        df_keys = pd.DataFrame(keys)
        df_keys = df_keys.sort_values(by=0)
        df_keys = df_keys.reset_index(drop=True)
        key_index = list(df_keys.index)

        num_keys = len(key_index)
        print(num_keys)

        dic_new_sys = {}
        if (num_ext_frames >= num_keys):

            for ik in key_index:

                key = df_keys[0].loc[ik]
                dic_new_sys[key] = {}

                NAME_FRAME = FOLDER_SYSTEMS + '_' + SYSTEM_NAME + '_' +\
                        str(int(key)) + '.pkl'
                PATH_FRAME = os.path.join(PATH_EXT, NAME_FRAME)
                tmp_df = pd.read_pickle(PATH_FRAME)
                dic_new_sys[key]['df'] = tmp_df

        else:

            for ik in key_index:
                
                dic_e = {}
                dic_e['x'] = {}
                dic_e['y'] = {}
                dic_e['z'] = {}
                
                key = df_keys[0].loc[ik]
                dic_new_sys[key] = {}

                df_sys = dic_sys[key]['df']
                df_e = df_sys.copy()
                
                box = df_dims.loc[[key]]
                
                tmp_cc = df_cc[df_cc['timef'] <= key]
                cross_atoms = tmp_cc['id'].unique()
                
                for iatom in df_sys.index:
                    
                    if iatom in cross_atoms:
                        
                        tmp2_df = tmp_cc[tmp_cc['id'] == iatom]
                        tmp2_df = tmp2_df.sort_values(by='timef')
                        
                        x = df_sys['x'].loc[iatom]
                        y = df_sys['y'].loc[iatom]
                        z = df_sys['z'].loc[iatom]
                        
                        edx, edy, edz = self.deltasExtended(df=tmp2_df,
                                box=box)
                        
                        ex = x + edx
                        ey = y + edy
                        ez = z + edz
                        
                        dic_e['x'][iatom] = ex
                        dic_e['y'][iatom] = ey
                        dic_e['z'][iatom] = ez
                        
                    else:
                        
                        x = df_sys['x'].loc[iatom]
                        y = df_sys['y'].loc[iatom]
                        z = df_sys['z'].loc[iatom]
                        
                        dic_e['x'][iatom] = x
                        dic_e['y'][iatom] = y
                        dic_e['z'][iatom] = z
                        
                tmp_e = pd.DataFrame(dic_e)
                df_e.update(tmp_e)    
                
                dic_new_sys[key]['df'] = df_e

                NAME_FRAME = FOLDER_SYSTEMS + '_' + SYSTEM_NAME + '_' +\
                        str(int(key)) + '.pkl'

                PATH_FRAME = os.path.join(PATH_EXT, NAME_FRAME)
                df_e.to_pickle(PATH_FRAME)


        return dic_new_sys
    
    def move2Point(self, **kwargs):

        dic_sys = kwargs.get('dic_sys', 'NULL')
        fixed_point = kwargs.get('fixed_point', 'NULL')

        df_CM = self.get_CM_from_dic(dic_grl=dic_sys)
        df_displacements = df_CM - fixed_point

        keys = list(dic_sys.keys())
        df_keys = pd.DataFrame(keys)
        df_keys = df_keys.sort_values(by=0)
        df_keys = df_keys.reset_index(drop=True)
        key_index = list(df_keys.index)
        
        dic_new = {}
        for ik in key_index:
            
            key = df_keys[0].loc[ik]
            dic_new[key] = {}

            move_vector = df_displacements.loc[key].values
            
            df_sys = dic_sys[key]['df'] 
            tmp_df = df_sys[['x', 'y', 'z']]
            tmp_df = tmp_df - move_vector
            
            df_sys.update(tmp_df)
            dic_new[key]['df'] = df_sys


        return dic_new

    def moveALL2Point(self, **kwargs):

        dic_SDS = kwargs.get('dic_SDS', 'NULL')
        dic_Pb = kwargs.get('dic_Pb', 'NULL')
        fixed_point = kwargs.get('fixed_point', 'NULL')
        df_dims = kwargs.get('df_dims', 'NULL')
        
        df_CM = self.get_CM_from_dic(dic_grl=dic_SDS)
        df_dSDS = df_CM - fixed_point

        keys = list(dic_SDS.keys())
        df_keys = pd.DataFrame(keys)
        df_keys = df_keys.sort_values(by=0)
        df_keys = df_keys.reset_index(drop=True)
        key_index = list(df_keys.index)
        
        dic_nSDS = {}
        dic_nPb = {}
        for ik in key_index:
            

            key = df_keys[0].loc[ik]
            dic_nSDS[key] = {}
            dic_nPb[key] = {}

            box = df_dims.loc[[key]]

            Lx = box['x'].iloc[0]
            Ly = box['y'].iloc[0]
            Lz = box['z'].iloc[0]

            move_vector = df_dSDS.loc[key].values
            
            df_SDS = dic_SDS[key]['df'] 
            tmp_df = df_SDS[['x', 'y', 'z']]
            tmp_df = tmp_df - move_vector
            
            df_SDS.update(tmp_df)
            dic_nSDS[key]['df'] = df_SDS


            df_Pb = dic_Pb[key]['df'] 
            tmp_df = df_Pb[['x', 'y', 'z']]
            tmp_df = tmp_df - move_vector

            sx = tmp_df['x'].mod(Lx)
            sy = tmp_df['y'].mod(Ly)
            sz = tmp_df['z'].mod(Lz)

            tmp_df.update(sx)
            tmp_df.update(sy)
            tmp_df.update(sz)

            df_Pb.update(tmp_df)
            dic_nPb[key]['df'] = df_Pb


        return dic_nSDS, dic_nPb


    def create_movie_2dics(self, **kwargs):

        dic1 = kwargs.get('dic1', 'NULL')
        dic2 = kwargs.get('dic2', 'NULL')
        PATH_MOVIE = kwargs.get('path_movie', 'movie.xyz')

        keys = list(dic1.keys())
        df_keys = pd.DataFrame(keys)
        df_keys = df_keys.sort_values(by=0)
        df_keys = df_keys.reset_index(drop=True)        
        
        key = df_keys[0].loc[0]

        df1 = dic1[key]['df']
        df2 = dic2[key]['df']
        df_res = df1.append(df2, ignore_index=True)
        self.df2xyz(df_res, PATH_MOVIE, key)
        
        key_index = list(df_keys.index)

        for ik in key_index[1:]:
            
            key = df_keys[0].loc[ik]    
            
            df1 = dic1[key]['df']
            df2 = dic2[key]['df']
            df_res = df1.append(df2, ignore_index=True)

            self.append_df2xyz(df_res, PATH_MOVIE, key)

        return


###############


    def xyz2df(self, path):

        dic = {}
        dic['symbol'] = {}
        dic['x'] = {}
        dic['y'] = {}
        dic['z'] = {}
        
        F = open(path, 'r')
        line =  F.readline()
        atoms = float(line.split()[0])
        line = next(F)

        i = 1
        for line in F:
            
            symbol = line.split()[0]
            x = float(line.split()[1])
            y = float(line.split()[2])
            z = float(line.split()[3])
            
            dic['symbol'][i] = symbol
            dic['x'][i] = x
            dic['y'][i] = y
            dic['z'][i] = z
            
            if i >= atoms:
                break
            i+=1

        return pd.DataFrame(dic)



    def water_density(self, temp):
        
        #temp in C

        a1 = -3.983035
        a2 = 301.797
        a3 = 522528.9
        a4 = 69.34881
        a5 = 999.97495
        
        A = (temp + a1)**2
        B = temp + a2
        C = a3*(temp + a4)
        
        return a5*(1-(A*B/C))*1e-3


    def volEsfera(self, r_mic):
        #r en angstroms
        return (4/3)*np.pi*r_mic**3


    def symbol2Id(self, symbol):
        
        # periodic-table.json
        path = "../data/general/periodic-table.json"
        df = pd.read_json(path)

        return df['atomicNumber'][df['symbol']==symbol].iloc[0]
        

    def atomicMass(self, symbol):
        
        path = "../data/general/atomic-mass-list.csv"
        df = pd.read_csv(path, sep=" ", header=None)
        
        Id = self.symbol2Id(symbol)

        return df[1][df[0]== Id].iloc[0]

        
    def molar_mass(self, path):
        
        df_xyz = self.xyz2df(path)
        
        symbols = list(df_xyz['symbol'].unique())

        masa_molar = 0
        for symbol in symbols:

            mm = self.atomicMass(symbol)
            n = df_xyz['symbol'][df_xyz['symbol']== symbol].count()
            masa_molar+= n*mm    
        
        return masa_molar


    def vol_cube_length(self, path, dens, num):
        
        masa_molar = self.molar_mass(path)
        
        vol = (masa_molar*num)/(dens*6.022*10*10)
        
        return np.power(vol, 1/3)


    def create_topol(self, **kwargs):

        user = kwargs.get('user', 'NULL')

        # dar celda 0
        gro_celda0 = kwargs.get('gro_celda0', 'NULL')
        dic_celda0 = gro_celda0.get_general_info()
        dfn_celda0 = gro_celda0.get_mols_info()

        # name ciclo
        NAME_CICLO = kwargs.get('name_ciclo', 'NULL')

        # dado, arbitrario
        path_ff = kwargs.get('path_ff', 'NULL')
        PATH_FF = path_ff

        # El path del topol debe estar libre donde estan las carpetas
        PATH_TOPOL = kwargs.get('path_topol', 'NULL')

        f = open(PATH_TOPOL, 'w')
        f.write("#include ")
        f.write('"' + PATH_FF + '"')
        f.write("\n\n")
        f.write("[ system ]\n")
        f.write(NAME_CICLO)
        f.write("\n\n")
        f.write("[ molecules ]\n")
        for idx in dfn_celda0.index:
            
            tipo_mol = dfn_celda0['tipo mol'].loc[idx]
            total_num = dfn_celda0['total num'].loc[idx]
            f.write("{:>5}{:>5}\n".format(tipo_mol, total_num))
            
            
        f.close()

        return 

    def max_xvg_valley(self, **kwargs):
            
        path_xvg = kwargs.get('path_xvg', 'NULL')
        kumbral = kwargs.get('kumbral', 0.03)
        
        df_xvg = self.xvg2df(path_xvg)
        y = df_xvg['y'].values

        peaks, _ = find_peaks(y, height=0)
        df_ph = pd.DataFrame(_)

        maxy = df_ph['peak_heights'].max()
        miny = df_ph['peak_heights'].min()

        delta1 = (maxy - miny)

        valle_umbral_down = maxy - delta1*kumbral
        valle_umbral_up = maxy + delta1*kumbral

        region_valle = []
        for idx in df_xvg.index:
            x = df_xvg['x'].loc[idx]
            y = df_xvg['y'].loc[idx]
            if ((y >= valle_umbral_down) and (y <= valle_umbral_up)):
                region_valle.append(x)

        min_zvalle = min(region_valle)
        max_zvalle = max(region_valle)

        return (min_zvalle, max_zvalle)


    def create_grompp(self, **kwargs):

        PATH_GROMPP = kwargs.get('path_grompp', 'NULL')
        df = kwargs.get('df_grompp', 'NULL')
        comment_opts = kwargs.get('comment_opts', [])

        f = open(PATH_GROMPP, 'w')
        for col in df.columns:
            
            if col == "gmx":
                continue
            
            if col == "user":
                continue
            
            value = str(df[col].iloc[0])

            if col in comment_opts:
                f.write(";{:<30} = {:<30}\n".format(col, value))
            else:
                f.write("{:<30} = {:<30}\n".format(col, value))
            
        f.close()

        return

    def rclean_xvg(self, **kwargs):
        
        # lee un xvg que solo tiene
        # columnas de datos
        # i.e esta limpio
        
        path = kwargs.get('path', 'NULL')
        x = kwargs.get('x', 'x')
        y = kwargs.get('y', 'y')
        
        xs = []
        ys = []
        
        f = open(path, 'r')
        for line in f:
            
            sline = line.split()
            xv = float(sline[0])
            yv = float(sline[1])
            
            xs.append(xv)
            ys.append(yv)
       
        return pd.DataFrame({x: xs, y: ys})



    def create_plot(self, **kwargs):
        
        dic = {}
        dic['mean'] = {}
        
        df = kwargs.get('df', 'NULL')
        path_to_save = kwargs.get('path_to_save', 'NULL')
        
        xx = kwargs.get('x', 'x')
        yy = kwargs.get('y', 'y')
        
        x0 = df[xx].iloc[0]
        xf = df[xx].iloc[-1]
        
        x0 = kwargs.get('x0', x0)
        xf = kwargs.get('xf', xf)
        
    #     ax = df.plot(kind='line', color='g', x=xx, y=yy, linewidth=1.0)
        xs = df[xx].values
        ys = df[yy].values

        fig, ax = plt.subplots()
        plt.plot(xs, ys)
        
        x = np.arange(0, df[xx].iloc[-1])
        m = 0

        x0 = df[xx].iloc[0]
        xf = df[xx].iloc[-1]

        b = df[yy].loc[int((xf/2)):].mean()
        y = m*x + b

        ax.text(0.95, 0.01, b,
                verticalalignment='bottom', horizontalalignment='right',
                transform=ax.transAxes,
                color='green', fontsize=15)

        plt.plot(x, y, 'r')
        ax.set_ylabel(yy)
        ax.set_xlabel(xx)

        fig = ax.get_figure()
        fig.set_size_inches(6, 5)

        fig.savefig(path_to_save, format="png")
        plt.close()
        
        dic['mean'][0] = b
        
        return pd.DataFrame(dic)
        
        

    def pdb2gro(self, **kwargs):
        gmx = kwargs.get("gmx", '/usr/local/gromacs/bin/gmx')

        path_pdb = kwargs.get("path_pdb", "NULL")

        _ = os.path.split(path_pdb)
        path_gro = os.path.join(_[0], os.path.splitext(_[1])[0] + ".gro")    
        path_gro = kwargs.get("path_gro", path_gro)
        cmd = [gmx, 'editconf',
               '-f', path_pdb,
               '-o', path_gro]
        cmd = [str(item) for item in cmd]
        process = subprocess.run(cmd, check=True, stdout=subprocess.PIPE, universal_newlines=True)  

        return path_gro



    def wrapper_create_dirs(self, paths):

        for path in paths:
            cmd = ['mkdir', '-p', path]
            cmd = [str(item) for item in cmd]
            process = subprocess.run(cmd, check=True, stdout=subprocess.PIPE, universal_newlines=True)

        return


    def copy_to(self, **kwargs):

        PATH_IN = kwargs.get("path_in", "NULL")
        PATH_OUT = kwargs.get("path_out", "NULL")

        cmd = ["cp", PATH_IN, PATH_OUT]

        cmd = [str(item) for item in cmd]
        process = subprocess.run(cmd, check=True, stdout=subprocess.PIPE, universal_newlines=True)    

        return
    
    def copy_file_to(self, **kwargs):

        PATH_IN = kwargs.get("path_in", "NULL")
        PATH_OUT = kwargs.get("path_out", "NULL")

        cmd = ["cp", PATH_IN, PATH_OUT]

        cmd = [str(item) for item in cmd]
        process = subprocess.run(cmd, check=True, stdout=subprocess.PIPE, universal_newlines=True)    

        return    
    
    def copy_folder_to(self, **kwargs):

        PATH_IN = kwargs.get("path_in", "NULL")
        PATH_OUT = kwargs.get("path_out", "NULL")

        cmd = ["cp", "-r", PATH_IN, PATH_OUT]

        cmd = [str(item) for item in cmd]
        process = subprocess.run(cmd, check=True, stdout=subprocess.PIPE, universal_newlines=True)    

        return        
        
            
    def read_gyrate(self, **kwargs):
        
        path = kwargs.get("path", "NULL")
        
        # @ s0 legend "Rg"
        # @ s1 legend "RgX"
        # @ s2 legend "RgY"
        # @ s3 legend "RgZ"

        dic = {}
        
        dic['t'] = {}
        dic['Rg'] = {}
        dic['RgX'] = {}
        dic['RgY'] = {}
        dic['RgZ'] = {}
        
        f = open(path, 'r')
        idx = 0
        for line in f:
            sp = line.split()
            dic['t'][idx] = float(sp[0])
            dic['Rg'][idx] = float(sp[1])
            dic['RgX'][idx] = float(sp[2])
            dic['RgY'][idx] = float(sp[3])
            dic['RgZ'][idx] = float(sp[4])
            idx+=1
            
        return pd.DataFrame(dic)
        
           
    def read_eccentricity(self, **kwargs):
        
        path = kwargs.get("path", "NULL")
        
        # @ s0 legend "Axis 1 (major)"
        # @ s1 legend "Axis 2 (middle)"
        # @ s2 legend "Axis 3 (minor)"

        dic = {}
        
        dic['t'] = {}
        dic['major'] = {}
        dic['middle'] = {}
        dic['minor'] = {}
        
        f = open(path, 'r')
        idx = 0
        for line in f:
            sp = line.split()
            dic['t'][idx] = float(sp[0])
            dic['major'][idx] = float(sp[1])
            dic['middle'][idx] = float(sp[2])
            dic['minor'][idx] = float(sp[3])
            idx+=1
            
        return pd.DataFrame(dic)
    
    
    def create_frame_ndx(self, **kwargs):

        frames = kwargs.get("frames", [0])

        path_fr_ndx = kwargs.get("path_fr_ndx", "frame.ndx")

        f = open(path_fr_ndx, "w")
        f.write("[ frames ]\n")
        for frame in frames:
            f.write("{}\n".format(frame))

        f.close()

        return
        
    
    def del_carpet(self, PATH):

        cmd = ["rm", "-rf", PATH]
        cmd = [str(item) for item in cmd]
        process = subprocess.run(cmd, check=True, stdout=subprocess.PIPE, universal_newlines=True)    

        return    
    
    def del_files(self, paths):

        for path in paths:
            cmd = ['rm', path]
            cmd = [str(item) for item in cmd]
            process = subprocess.run(cmd, check=True, stdout=subprocess.PIPE, universal_newlines=True)
  

        return        
    
    def add_atom_df(self, **kwargs):
        
        p = kwargs.get("p", [0, 0, 0])
        symbol = kwargs.get("symbol", 'C')
        df = kwargs.get("df", {})
        idx = kwargs.get("idx", 0)

        create = kwargs.get("create", True)

        dic = {'x':{}, 'y':{}, 'z':{}, 'symbol': {}}
        dic['x'][idx] = p[0]
        dic['y'][idx] = p[1]
        dic['z'][idx] = p[2]
        dic['symbol'][idx] = symbol
        tmp_df = pd.DataFrame(dic)

        if create:
            return tmp_df

        else:
            idx = df.index[-1] + 1
            tmp_df = tmp_df.set_index(pd.Index([idx]))

            return df.append(tmp_df)
        
        
    def rotation_matrix_from_vectors(self, vec1, vec2):
        """
         Find the rotation matrix that aligns vec1 to vec2
        :param vec1: A 3d "source" vector
        :param vec2: A 3d "destination" vector
        :return mat: A transform matrix (3x3) which when applied to vec1, aligns it with vec2.
        
        https://math.stackexchange.com/questions/180418/
        calculate-rotation-matrix-to-align-vector-a-to-vector-b-in-3d
        
        https://stackoverflow.com/questions/45142959/
        calculate-rotation-matrix-to-align-two-vectors-in-3d-space        
        
        """
        a, b = (vec1 / np.linalg.norm(vec1)).reshape(3), (vec2 / np.linalg.norm(vec2)).reshape(3)
        v = np.cross(a, b)
        c = np.dot(a, b)
        s = np.linalg.norm(v)
        kmat = np.array([[0, -v[2], v[1]], [v[2], 0, -v[0]], [-v[1], v[0], 0]])
        rotation_matrix = np.eye(3) + kmat + kmat.dot(kmat) * ((1 - c) / (s ** 2))
        
        return rotation_matrix   
    
    
    def f_Niso(self, **kwargs):

    #     Niso = kwargs.get("Niso", "NULL")
        Nhoh = kwargs.get("Nhoh", "NULL")
        Naot = kwargs.get("Naot", "NULL")
        Nna = kwargs.get("Nna", "NULL")
        fiso = kwargs.get("fiso", "NULL")

        pathiso = "../data/inputs/reverce_micelles/xyz/g016.xyz"
        pathaot = "../data/inputs/reverce_micelles/xyz/aot.xyz"
        pathhoh = "../data/inputs/reverce_micelles/xyz/spce_hoh.xyz"
        pathna = "../data/inputs/reverce_micelles/xyz/E0XM_allatom_optimised_geometry.xyz"

        Miso = self.molar_mass(pathiso)
        Mhoh = self.molar_mass(pathhoh)
        Maot = self.molar_mass(pathaot)
        Mna = self.molar_mass(pathna)

        b = fiso*(Mhoh*Nhoh + Maot*Naot + Mna*Nna)
        a = Miso*(1.0-fiso)

        return np.divide(b, a)
    
    
    def f_fiso(self, **kwargs):

        Niso = kwargs.get("Niso", "NULL")
        Nhoh = kwargs.get("Nhoh", "NULL")
        Naot = kwargs.get("Naot", "NULL")
        Nna = kwargs.get("Nna", "NULL")

        pathiso = "../data/inputs/reverce_micelles/xyz/g016.xyz"
        pathaot = "../data/inputs/reverce_micelles/xyz/aot.xyz"
        pathhoh = "../data/inputs/reverce_micelles/xyz/spce_hoh.xyz"
        pathna = "../data/inputs/reverce_micelles/xyz/E0XM_allatom_optimised_geometry.xyz"

        Miso = self.molar_mass(pathiso)
        Mhoh = self.molar_mass(pathhoh)
        Maot = self.molar_mass(pathaot)
        Mna = self.molar_mass(pathna)

        a = Miso*Niso
        b = a + Mhoh*Nhoh + Maot*Naot + Mna*Nna

        return np.divide(a, b)
    
    
    def df2gro_newmol_num(self, **kwargs):

        df = kwargs.get("df", "NULL")
        dfn = kwargs.get("dfn", "NULL")
        name = kwargs.get("name", "gro")
        path = kwargs.get("path", "NULL")
        frame = kwargs.get("frame", 0)
        box = kwargs.get("box", [20, 20, 20])
        flag_velocities = kwargs.get("flag_velocities", True)

        Lx, Ly, Lz = box

        with open(path, 'w') as fp:
            txt = 'Generated by trjconv : {} t=   {}\n'.format(name, frame)
            fp.write(txt)
            fp.write("    {}\n".format(len(df)))

            if flag_velocities:
                for idx in df.index:
                    sym = df['symbol'].loc[idx]
                    sym2 = df['symbol2'].loc[idx]
                    x = df['x'].loc[idx]
                    y = df['y'].loc[idx]
                    z = df['z'].loc[idx]
                    vx = df['vx'].loc[idx]
                    vy = df['vy'].loc[idx]
                    vz = df['vz'].loc[idx]

                    tipo = df['tipo'].loc[idx]
                    symbol = df['symbol'].loc[idx]
                    tipo_mol = df['tipo mol'].loc[idx]

                    c = len(tipo_mol)
                    ntipo = int(dfn['num_mol'].loc[idx])
                    wtipo = tipo[-c:]

                    fp.write("{:>5d}{:<7}{:>3}{:>5}".format(ntipo, tipo_mol, symbol, idx))
                    fp.write("{:>8.3f}{:>8.3f}{:>8.3f}".format(x, y, z))
                    fp.write("{:>8.4f}{:>8.4f}{:>8.4f}\n".format(vx, vy,vz))
                fp.write("{:>9.4f}{:>9.4f}{:>9.4f}\n".format(Lx, Ly, Lz))
            else:  
                for idx in df.index:
                    sym = df['symbol'].loc[idx]
                    sym2 = df['symbol2'].loc[idx]
                    x = df['x'].loc[idx]
                    y = df['y'].loc[idx]
                    z = df['z'].loc[idx]

                    tipo = df['tipo'].loc[idx]
                    symbol = df['symbol'].loc[idx]
                    tipo_mol = df['tipo mol'].loc[idx]

                    c = len(tipo_mol)
                    ntipo = int(dfn['num_mol'].loc[idx])
                    wtipo = tipo[-c:]

                    fp.write("{:>5d}{:<7}{:>3}{:>5}".format(ntipo, tipo_mol, symbol, idx))
                    fp.write("{:>8.3f}{:>8.3f}{:>8.3f}\n".format(x, y, z))
                fp.write("{:>9.4f}{:>9.4f}{:>9.4f}\n".format(Lx, Ly, Lz))                

        return    


    def get_nummolcol(self, df):

        dic = {}
        dic['num_mol'] = {}
        dic['tipo mol'] = {}
        for idx in df.index:

            tipo_mol = df['tipo mol'].loc[idx]
            tipo = df['tipo'].loc[idx]
            c = len(tipo_mol)
            ntipo = int(tipo[:-c])
            dic['num_mol'][idx] = ntipo
            dic['tipo mol'][idx] = tipo_mol

        return pd.DataFrame(dic)


    def script2code(self, **kwargs):
        
        path_in = kwargs.get("path_in", "NULL")
        path_out = kwargs.get("path_out", "NULL")
        
        fin = open(path_in, 'r')
        fout = open(path_out, 'w')
        with open(path_in) as fin: 
            for line in fin:
                idx = line.rfind("\n") # Claro! por cada salto de linea
                # tengo que dar uno! old genius :D
                fout.write("f.write('{}".format(line[:idx]) + "\\n'" + ")")
                fout.write("\n")

        fout.close()
        
        return

    def f_NMetanol(self, **kwargs):

    #     Niso = kwargs.get("Niso", "NULL")
        Nhoh = kwargs.get("Nhoh", "NULL")
        Naot = kwargs.get("Naot", "NULL")
        Nna = kwargs.get("Nna", "NULL")
        Niso = kwargs.get("Niso", "NULL")
        fmolar = kwargs.get("fmolar", "NULL")

        pathiso = "../data/inputs/reverce_micelles/xyz/g016.xyz"
        pathaot = "../data/inputs/reverce_micelles/xyz/aot.xyz"
        pathhoh = "../data/inputs/reverce_micelles/xyz/spce_hoh.xyz"
        pathna = "../data/inputs/reverce_micelles/xyz/E0XM_allatom_optimised_geometry.xyz"
        pathmet = "../data/inputs/rms_contaminantes/xyz/jqkk.xyz"

        Miso = self.molar_mass(pathiso)
        Mhoh = self.molar_mass(pathhoh)
        Maot = self.molar_mass(pathaot)
        Mna = self.molar_mass(pathna)
        Mmet = self.molar_mass(pathmet)

        b = fmolar*(Mhoh*Nhoh + Maot*Naot + Mna*Nna + Miso*Niso)
        a = Mmet*(1.0-fmolar)
        
        return np.divide(b, a)
    
    
    def f_fMetanol(self, **kwargs):

        Niso = kwargs.get("Niso", "NULL")
        Nhoh = kwargs.get("Nhoh", "NULL")
        Naot = kwargs.get("Naot", "NULL")
        Nna = kwargs.get("Nna", "NULL")
        Nmet = kwargs.get("Nmet", "NULL")

        pathiso = "../data/inputs/reverce_micelles/xyz/g016.xyz"
        pathaot = "../data/inputs/reverce_micelles/xyz/aot.xyz"
        pathhoh = "../data/inputs/reverce_micelles/xyz/spce_hoh.xyz"
        pathna = "../data/inputs/reverce_micelles/xyz/E0XM_allatom_optimised_geometry.xyz"
        pathmet = "../data/inputs/rms_contaminantes/xyz/jqkk.xyz"

        Miso = self.molar_mass(pathiso)
        Mhoh = self.molar_mass(pathhoh)
        Maot = self.molar_mass(pathaot)
        Mna = self.molar_mass(pathna)
        Mmet = self.molar_mass(pathmet)

        a = Mmet*Nmet
        b = Miso*Niso + Mhoh*Nhoh + Maot*Naot + Mna*Nna + a

        return np.divide(a, b)
    
    
    def getLcube_A(self, path_xyz, p, N):

        M = self.molar_mass(path=path_xyz)
        a = np.prod([N, M, 1e4])
        b = np.multiply(6.02214076, p)

        return np.power(np.divide(a,b), 1/3)    

    def xvg2df_3(self, **kwargs):
        
        path = kwargs.get('path', "NULL")
        xx = kwargs.get('x', 'x')
        yy = kwargs.get('y', 'y')
        zz = kwargs.get('z', 'z')

        with open(path, 'r') as fp:
            
            dic_gr = {}
            dic_gr[xx] = {}
            dic_gr[yy] = {}
            dic_gr[zz] = {}
            
            i = 0
            for line in fp:
                sp = line.split()
                
                
                if sp[0] not in ['#', '@', '@TYPE', 'r', 'g']:
                
                    try:
                        r = float(sp[0])
                    except:
                        print("not a number, pass")
                        continue
                
                    r = float(sp[0])
                    gr = float(sp[1])
                    gr2 = float(sp[2])

                    dic_gr[xx][i] = r
                    dic_gr[yy][i] = gr
                    dic_gr[zz][i] = gr2
                    
                    i+=1

        return pd.DataFrame(dic_gr)

    def get_minmax_df(self, **kwargs):
        
        df = kwargs.get("df", "NULL")
        
        min_z = df['z'].min()
        max_z = df['z'].max()

        min_x = df['x'].min()
        max_x = df['x'].max()

        min_y = df['y'].min()
        max_y = df['y'].max()

        dic = {}

        dic['min'] = {}
        dic['max'] = {}

        dic['min']['x'] = df['x'].min()
        dic['max']['x'] = df['x'].max()

        dic['min']['y'] = df['y'].min()
        dic['max']['y'] = df['y'].max()

        dic['min']['z'] = df['z'].min()
        dic['max']['z'] = df['z'].max()


        return pd.DataFrame(dic)

    def get_minmax_dims(self, **kwargs):
        
        df = kwargs.get("df", {})
        df = df.copy()
        
        min_z = df['min'].loc['z']
        max_z = df['max'].loc['z']

        min_x = df['min'].loc['x']
        max_x = df['max'].loc['x']

        min_y = df['min'].loc['y']
        max_y = df['max'].loc['y']
        
        xdim = max_x - min_x
        ydim = max_y - min_y
        zdim = max_z - min_z
        
        dic = {}
        dic['xdim'] = {}
        dic['ydim'] = {}
        dic['zdim'] = {}
        
        dic['xdim'][0] = xdim
        dic['ydim'][0] = ydim
        dic['zdim'][0] = zdim
        
        return pd.DataFrame(dic)


    def get_center_of_space_orthogonal(self, **kwargs):
        
        df = kwargs.get("df", "NULL")

        tmp1 = self.get_minmax_df(df=df)
        tmp2 = self.get_minmax_dims(df=tmp1)

        minz = tmp1['min'].loc["z"]
        minx = tmp1['min'].loc["x"]
        miny = tmp1['min'].loc["y"]

        maxz = tmp1['max'].loc["z"]
        maxx = tmp1['max'].loc["x"]
        maxy = tmp1['max'].loc["y"]

        dimz = tmp2['zdim'].loc[0]
        dimx = tmp2['xdim'].loc[0]
        dimy = tmp2['ydim'].loc[0]

        cmx = minx + dimx/2 
        cmy = miny + dimy/2 
        cmz = minz + dimz/2
       
        dic = {}
        dic['cmx'] = {}
        dic['cmy'] = {}
        dic['cmz'] = {}

        key = 0
        dic['cmx'][key] = cmx
        dic['cmy'][key] = cmy
        dic['cmz'][key] = cmz
        
        
        return pd.DataFrame(dic)


